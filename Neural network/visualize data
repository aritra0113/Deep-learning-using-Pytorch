import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
import sklearn.datasets

x,y=sklearn.datasets.make_moons(200,noise=0.20)
plt.scatter(x[:,0],x[:,1],s=40,c=y,cmap=plt.cm.Spectral)
plt.show()
x=torch.FloatTensor(x)
y=torch.LongTensor(y)
class FeedForward(torch.nn.Module):#we want to inherit nn module because of the linaer functionality
    def __init__(self,input_neurons,hidden_neurons,output_neurons):
        super(FeedForward,self).__init__()
        self.hidden=nn.Linear(input_neurons,hidden_neurons)
        self.out=nn.Linear(hidden_neurons,output_neurons)
    def forward(self,x):#we are overriding the pre-existing forwad function
        x= self.hidden(x)
        x=F.relu(x)
        x=self.out(x)
        return x
network=FeedForward(2,50,2) 
optimizer=torch.optim.SGD(network.parameters(),lr=0.02)
loss_function= torch.nn.CrossEntropyLoss()    #there 2 output classes so we cannot use binary cross entropy we have to use softmax
#training the neural network
plt.ion()
for epoch in range(10000):
    out=network(x) #forward propagate the training data
    loss=loss_function(out,y)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
    
    if epoch%1000==0:
        #show the learnig process uptil now
      
        max_value,prediction=torch.max(out,1)
        #matplotlib expects a Numpy array so we cannot continue with the torch.tensor
        pedicted_y=prediction.data.numpy() #method to convert torch tensor to numpy array
        target_y=y.data.numpy()
        plt.scatter(x.data.numpy()[:,0],x.data.numpy()[:,1],s=40,c=pedicted_y,cmap=plt.cm.Spectral,lw=0)
        accuracy=(pedicted_y==target_y).sum()/target_y.size;
        plt.text(3,-1,'Accuracy={:.2f}'.format(accuracy),fontdict={'size':14})
        plt.pause(.1)

plt.ioff()
plt.show()
        
